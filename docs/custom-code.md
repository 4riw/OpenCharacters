If you open the advanced options in the character creation area then you'll see the "custom code" input. This allows you to define some JavaScript functions that extend the functionality of your character.

Some examples of what you can do with this:

 * Give your character access to the internet (e.g. so you can ask it to summarise webpages)
 * Improve your character's memory by setting up an embedding/retrieval system (see "Storing Data" section below) 
 * Give your character a custom voice using an API like [ElevenLabs](https://api.elevenlabs.io/docs)
 * Allow your character to run custom JS or [Python](https://github.com/pyodide/pyodide/) code
 * Give your character the ability to create pictures using Stable Diffusion
 * Auto-delete/retry messages from your character that contain certain keywords

## The `processMessages` Function

You can define an `async` function called `processMessages` that accepts a single input: `messages`, which is an array that looks like this:
```json5
[
  {
    "id": 0,
    "author": "user",
    "hidden": false,
    "content": "Hello",
  },
  {
    "id": 1,
    "author": "ai",
    "hidden": false,
    "content": "Hello, how can I help you today?",
  }
]
```
The most recent message is at the bottom.

Your `processMessages` function can alter messages, and add messages to this array, and then it should return that updated `messages` array.

The `processMessages` function is executed after *every* turn in the conversation. It 'sees' all the messages posted so far.

Below is a example of a `processMessages` function that you could put in the "custom code" text area of a character. This `processMessages` function simply replaces all instances of `:)` with `૮ ˶ᵔ ᵕ ᵔ˶ ა`.

```js
async function processMessages(messages) {
  for(let m of messages) {
    m.content = m.content.replaceAll(":)", "૮ ˶ᵔ ᵕ ᵔ˶ ა");
  }
  return messages;
}
```

Here's one which allows the AI to see the contents of webpages if you put URLs in your messages:

```js
// note that you need to replace corsproxy.com with an actual cors proxy
async function processMessages(messages) {
  let lastMessage = messages.at(-1);
  if(lastMessage.author === "user") {
    let urlsInLastMessage = [...lastMessage.content.matchAll(/https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/g)].map(m => m[0]);
    if(urlsInLastMessage.length === 0) return messages;
    // just grab contents for last URL
    let html = await fetch("https://corsproxy.com/?url="+encodeURIComponent(urlsInLastMessage.at(-1)).then(r => r.text()));
    let doc = new DOMParser().parseFromString(html, "text/html");
    let text = [...doc.querySelectorAll("h1,h2,h3,h4,p")].map(el => el.textContent).join("\n");
    text = text.slice(0, 1000); // only grab first 1000 characters
    messages.push({
      author: "user",
      hidden: true, // hide the message so it doesn't get in the way of the conversation
      content: "I've copied the content of the webpage that I just linked: \n\n"+text,
    });
  } else {
    return messages;
  }
}
```

The function is executed securely (i.e. in a sandboxed iframe), so if you're using a character that was created by someone else (and that has some custom code), then their code won't be able to access your OpenAI API key, or your messages with other characters, for example. The `processMessages` function only has access to the `messages` array for your current conversation.

## Storing Data (not yet implemented! open an issue if you want it)

If you'd like to save some data that is generated by your custom code, then you can do that by using the special `storage` object. Just use it like a regular JS object - i.e. `storage.foo = 10`, and the data will be persisted - all custom code functions will have access to it, and it'll still be available after you refresh your browser. So for that particular conversation, `storage.foo` will always return `10` until you change it.

## Templating (not yet implemented! open an issue if you want it)

Your custom code may require some user inputs. For example, let's say you want to create a character that can access a Stable Diffusion API. If you want to share that character with the community, then you obviously wouldn't want to have your API key "hard coded" into the character. So you could just tell people "Hey, you need to edit the custom code - put your Stable Diffusion API key where it says API_KEY", but that's cumbersome, and it'd make it easy for people to accidentally share their API key with others. So instead you can write `{{API_KEY:Enter your Stable Diffusion API key here}}` in the place where you want the user's API key to go, and now when the users first tries to use your character, it'll ask them for their API key and store it for all future hat sessions with that character.
